{"pages":[],"posts":[{"title":"SpringBoot+RabbitMQ 示例","text":"RabbitMQ简介 RabbitMQ是实现AMQP(高级消息队列协议)的消息中间件的一种，用于分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 一些主要概念： 生产者 消息的生产方，负责将消息推送到消息队列 消费者 消息的最终接收方，负责监听队列中相应的消息，消费信息 队列 消息的寄存器，负责存放生产者产生的信息 模式： direct 直连模式，用于实例间的任务分发 topic 话题模式，通过可配置的规则分发给绑定的exchange上的队列 headers 适用于规则复杂的分发，用于headers里面的参数表达规则 fanout 分发给所有绑定到该exchange上的队列，忽略routing key 创建SpringBoot项目，引入RabbitMQ依赖12345&lt;!--RabbitMQ 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置application.properties文件1234567spring.application.name=springboot-rabbitmqspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.publisher-confirms=truespring.rabbitmq.virtual-host=/ RabbitMQ的五种模式1) 简单队列（模式）一个生产者对应一个消费者 生产者 1234567891011@Servicepublic class HelloProducer1 { @Resource private AmqpTemplate rabbitTemplate; public void send() { String sendMsg = \"hello1\"; System.out.println(\"Producer1 : \" + sendMsg); this.rabbitTemplate.convertAndSend(AmqpConfiguration.TEST_HELLO_SEND, sendMsg); }} 消费者 12345678910@Service@RabbitListener(queues = AmqpConfiguration.TEST_HELLO_SEND)public class HelloConsumer1 { @RabbitHandler public void consumer(String hello){ System.out.println(\"Consumer:\" + hello); }} 2) Work 模式一个生产者对应多个消费者 生产者 123456789101112public void work(){ for (int i = 1; i &lt;= 10; i++){ String msg = i + \"-&gt; work\"; System.out.println(\"Producer：\"+ msg); this.rabbitTemplate.convertAndSend(AmqpConfiguration.WORK_MODEL_QUEUE, msg); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }} 消费者 12345678910111213141516171819202122232425262728/** * 消费者1 * @param msg */ @RabbitListener(queues = AmqpConfiguration.WORK_MODEL_QUEUE) public void consumer1(String msg){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"consumer1 : \" + msg); } /** * 消费者2 * @param msg */ @RabbitListener(queues = AmqpConfiguration.WORK_MODEL_QUEUE) public void consumer2(String msg){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"consumer2 : \" + msg); } 3) 订阅模型-Fanout 订阅模型-Fanout也成为广播模式，流程如下 可以有多个消费者 每个消费者有自己的队列 每个队列都要绑定到Exchange（交换机） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 交换机把消息发送给绑定过的所有队列 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 生产者 12345678910111213141516/** * fanout-订阅模型 */public void fanout(){ String msg = \"fanout-订阅模型\"; for (int i = 1; i &lt;= 10; i++){ System.out.println(\"fanout : \" + msg + i); this.rabbitTemplate.convertAndSend(AmqpConfiguration.FANOUT_EXCHANGE_QUEUE, \"\", msg + i); } try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }} 消费者 123456789101112131415161718192021222324252627282930313233@Servicepublic class FanoutConsumer { /** * 消费者1 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"fanout1.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.FANOUT_EXCHANGE_QUEUE, ignoreDeclarationExceptions = \"true\", type = ExchangeTypes.FANOUT ) )) public void fanoutConsumer1(String msg){ System.out.println(\"fanoutConsumer1 :\" + msg); } /** * 消费者2 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"fanout2.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.FANOUT_EXCHANGE_QUEUE, ignoreDeclarationExceptions = \"true\", type = ExchangeTypes.FANOUT ) )) public void fanoutConsumer2(String msg){ System.out.println(\"fanoutConsumer2 :\" + msg); } 4) 订阅模型-Direct (路由模式) 在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。给特定的消费者消费。 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的 Routingkey与消息的 Routing key完全一致，才会接收到消息 produeer 1234567891011121314/** * 订阅模式-Direct(路由模式) */ public void direct(){ String msg = \"路由模式\"; for (int i = 0; i &lt;=10; i++){ rabbitTemplate.convertAndSend(AmqpConfiguration.DIRECT_EXCHANG_QUEUE, \"direct.routing.key\", msg + i); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } } consumer 12345678910111213141516171819202122232425262728293031323334@Servicepublic class DirectConsumer { /** * 消费者1 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"spring.direct1.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.DIRECT_EXCHANG_QUEUE, ignoreDeclarationExceptions = \"true\" ), key = {\"direct.routing.key\"} )) public void listen(String msg) { System.out.println(\"consumer1（路由模式1） 接收到消息\" + msg); } /** * 消费者2 key值不同 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"spring.direct2.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.DIRECT_EXCHANG_QUEUE, ignoreDeclarationExceptions = \"true\" ), key = {\"direct.routing.key2\"} )) public void listen2(String msg) { System.out.println(\"consumer2（路由模式2） 接收到消息：\" + msg); }} 5) 订阅模型-Topic (主题模式) Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： user.insert 通配符 规则 例子 # 匹配一个或多个词 topic.# 能够匹配 topic.xxx 或 topic.xxx.xxx * 匹配一个词 key.* 只能匹配key.xxx producer 1234567891011121314151617/** * Topic 模式 */public void topic(){ String msg = \"topic模式\"; for (int i = 1; i &lt;= 5; i ++){ rabbitTemplate.convertAndSend(AmqpConfiguration.TOPIC_EXCHANG_QUEUE, \"key.\" + i, msg + i + \"key=key.*\" ); rabbitTemplate.convertAndSend(AmqpConfiguration.TOPIC_EXCHANG_QUEUE, \"topic.\" + i, msg + i + \"-&gt;key=topic.*\" ); rabbitTemplate.convertAndSend(AmqpConfiguration.TOPIC_EXCHANG_QUEUE, \"topic.\" + i + \".test\", msg + i + \"key=topic.*.test\" ); } try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }} consumer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Servicepublic class TopicConsumer { /** * 消费者1 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"spring.topic.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.TOPIC_EXCHANG_QUEUE, ignoreDeclarationExceptions = \"true\" ), key = {\"key.*\"} )) public void listen(String msg) { System.out.println(\"consumer1（key=key.*） 接收到消息\" + msg); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } /** * 消费者2 key值不同 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"spring.topic2.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.TOPIC_EXCHANG_QUEUE, ignoreDeclarationExceptions = \"true\" ), key = {\"topic.*\"} )) public void listen2(String msg) { System.out.println(\"consumer2（key = topic.*） 接收到消息：\" + msg); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } /** * 消费者3 key值不同，区别于消费者2 * @param msg */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"spring.topic3.queue\", durable = \"true\"), exchange = @Exchange( value = AmqpConfiguration.TOPIC_EXCHANG_QUEUE, ignoreDeclarationExceptions = \"true\" ), key = {\"topic.#\"} )) public void listen3(String msg) { System.out.println(\"consumer3（key = topic.#） 接收到消息：\" + msg); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }} result(聪明的人已经知道为什是消费20条数据) 123456789101112131415161718192021222020-01-15 15:31:49.362 INFO 6932 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8012 (http) with context path '/rabbitmq-consumer'2020-01-15 15:31:49.365 INFO 6932 --- [ main] c.example.consumer.ConsumerApplication : Started ConsumerApplication in 2.225 seconds (JVM running for 3.38)consumer3（key = topic.#） 接收到消息：topic模式1 key=topic.*consumer1（key=key.*） 接收到消息topic模式1 key=key.*consumer2（key = topic.*） 接收到消息：topic模式1 key=topic.*consumer2（key = topic.*） 接收到消息：topic模式2 key=topic.*consumer1（key=key.*） 接收到消息topic模式3 key=key.*consumer3（key = topic.#） 接收到消息：topic模式1 key=topic.*.testconsumer2（key = topic.*） 接收到消息：topic模式3 key=topic.*consumer1（key=key.*） 接收到消息topic模式2 key=key.*consumer2（key = topic.*） 接收到消息：topic模式4 key=topic.*consumer3（key = topic.#） 接收到消息：topic模式2 key=topic.*consumer1（key=key.*） 接收到消息topic模式4 key=key.*consumer2（key = topic.*） 接收到消息：topic模式5 key=topic.*consumer3（key = topic.#） 接收到消息：topic模式2 key=topic.*.testconsumer1（key=key.*） 接收到消息topic模式5 key=key.*consumer3（key = topic.#） 接收到消息：topic模式3 key=topic.*consumer3（key = topic.#） 接收到消息：topic模式4 key=topic.*consumer3（key = topic.#） 接收到消息：topic模式3 key=topic.*.testconsumer3（key = topic.#） 接收到消息：topic模式4 key=topic.*.testconsumer3（key = topic.#） 接收到消息：topic模式5 key=topic.*consumer3（key = topic.#） 接收到消息：topic模式5 key=topic.*.test @源码地址传送门","link":"/2020/01/13/SpringBoot-RabbitMQ%E7%A4%BA%E4%BE%8B%E6%95%B4%E5%90%88/"},{"title":"RabbitMQ应用实战","text":"前言上一篇说到RabbitMQ的基本用法和几种模式的区别，这篇主要说一下它的应用场景+实战。RabbitMQ 作为目前应用相当广泛的消息中间件，在企业级应用、微服务应用中充当着重要的角色。特别是在一些典型的应用场景以及业务模块中具有重要的作用，比如业务服务模块解耦、异步通信、高并发限流、超时业务、数据延迟处理等。 RabbitMQ 官方拜读首先，让我们先拜读 RabbitMQ 官网的技术开发手册以及相关的 Features，感兴趣的朋友可以耐心的阅读其中的相关介绍，相信会有一定的收获，地址可见： RabbitMQ 官方网址 阅读该手册过程中，我们可以得知 RabbitMQ 其实核心就是围绕 “消息模型” 来展开的，其中就包括了组成消息模型的相关组件：生产者，消费者，队列，交换机，路由，消息等！而我们在实战应用中，实际上也是紧紧围绕着 “消息模型” 来展开撸码的！ 下面，我就介绍一下这一消息模型的演变历程，当然，这一历程在 RabbitMQ 官网也是可以窥览得到的！ 上面几个图就已经概述了几个要点，而且，这几个要点的含义可以说是字如其名！ 生产者：发送消息的程序 消费者：监听接收消费消息的程序 消息：一串二进制数据流 队列：消息的暂存区/存储区 交换机：消息的中转站，用于接收分发消息。其中有 fanout、direct、topic、headers 四种 路由：相当于密钥/第三者，与交换机绑定即可路由消息到指定的队列！ 正如上图所展示的消息模型的演变，接下来我们将以代码的形式实战各种典型的业务场景！","link":"/2020/01/16/RabbitMQ%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"}],"categories":[{"name":"Java技术分享","slug":"Java技术分享","link":"/categories/Java%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/categories/RabbitMQ/"}]}