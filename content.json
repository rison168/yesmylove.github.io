{"pages":[],"posts":[{"title":"SpringBoot+RabbitMQ示例整合","text":"简介 RabbitMQ RabbitMQ是实现AMQP(高级消息队列协议)的消息中间件的一种，用于分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 一些主要概念： 生产者 消息额生产方，负责将消息推送到消息队列 消费者 消息的最终接收方，负责监听队列中的对相应消息，消费信息 队列 消息的寄存器，负责存放生产者产生的信息 模式： direct 直连模式，用于实例间的任务分发 topic 话题模式，通过可配置的规则分发给绑定的exchange上的队列 headers 适用于规则复杂的分发，用于headers里面的参数表达规则 fanout 分发给所以的绑定到该exchange上的队列，忽略routing key 创建SpringBoot项目，引入RabbitMQ依赖12345&lt;!--RabbitMQ 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置application.properties文件1234567spring.application.name=springboot-rabbitmqspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.publisher-confirms=truespring.rabbitmq.virtual-host=/ RabbitMQ的五种模式1) 简单队列（模式）一个生产者对应一个消费者 生产者 1234567891011@Servicepublic class HelloProducer1 { @Resource private AmqpTemplate rabbitTemplate; public void send() { String sendMsg = \"hello1\"; System.out.println(\"Producer1 : \" + sendMsg); this.rabbitTemplate.convertAndSend(AmqpConfiguration.TEST_HELLO_SEND, sendMsg); }} 消费者 12345678910@Service@RabbitListener(queues = AmqpConfiguration.TEST_HELLO_SEND)public class HelloConsumer1 { @RabbitHandler public void consumer(String hello){ System.out.println(\"Consumer:\" + hello); }} 2) Work 模式一个生产者对应多个消费者 生产者 123456789101112public void work(){ for (int i = 1; i &lt;= 10; i++){ String msg = i + \"-&gt; work\"; System.out.println(\"Producer：\"+ msg); this.rabbitTemplate.convertAndSend(AmqpConfiguration.WORK_MODEL_QUEUE, msg); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }} 消费者 12345678910111213141516171819202122232425262728/** * 消费者1 * @param msg */ @RabbitListener(queues = AmqpConfiguration.WORK_MODEL_QUEUE) public void consumer1(String msg){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"consumer1 : \" + msg); } /** * 消费者2 * @param msg */ @RabbitListener(queues = AmqpConfiguration.WORK_MODEL_QUEUE) public void consumer2(String msg){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"consumer2 : \" + msg); } 3) 订阅模型-Fanout 订阅模型-Fanout也成为广播模式，流程如下 可以有多个消费者 每个消费者有自己的队列 每个队列都要绑定到Exchange（交换机） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 交换机把消息发送给绑定过的所有队列 队列的消费者都能拿到消息。实现一条消息被多个消费者消费","link":"/2020/01/13/SpringBoot-RabbitMQ%E7%A4%BA%E4%BE%8B%E6%95%B4%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"}],"categories":[{"name":"Java技术分享","slug":"Java技术分享","link":"/categories/Java%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}]}