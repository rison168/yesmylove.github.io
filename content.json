{"pages":[],"posts":[{"title":"SpringBoot+RabbitMQ示例整合","text":"1 简介 RabbitMQ RabbitMQ是实现AMQP(高级消息队列协议)的消息中间件的一种，用于分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 一些主要概念： 生产者 消息额生产方，负责将消息推送到消息队列 消费者 消息的最终接收方，负责监听队列中的对相应消息，消费信息 队列 消息的寄存器，负责存放生产者产生的信息 模式： direct 直连模式，用于实例间的任务分发 topic 话题模式，通过可配置的规则分发给绑定的exchange上的队列 headers 适用于规则复杂的分发，用于headers里面的参数表达规则 fanout 分发给所以的绑定到该exchange上的队列，忽略routing key 2 创建SpringBoot项目，引入RabbitMQ依赖12345&lt;!--RabbitMQ 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 3 配置application.properties文件1234567spring.application.name=springboot-rabbitmqspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.publisher-confirms=truespring.rabbitmq.virtual-host=/ 4 RabbitMQ的五种模式1) 简单队列（模式）一个生产者对应一个消费者 生产者 1234567891011@Servicepublic class HelloProducer1 { @Resource private AmqpTemplate rabbitTemplate; public void send() { String sendMsg = \"hello1\"; System.out.println(\"Producer1 : \" + sendMsg); this.rabbitTemplate.convertAndSend(AmqpConfiguration.TEST_HELLO_SEND, sendMsg); }} 消费者 12345678910@Service@RabbitListener(queues = AmqpConfiguration.TEST_HELLO_SEND)public class HelloConsumer1 { @RabbitHandler public void consumer(String hello){ System.out.println(\"Consumer:\" + hello); }} 2) Work 模式一个生产者对应多个消费者 生产者 123456789101112public void work(){ for (int i = 1; i &lt;= 10; i++){ String msg = i + \"-&gt; work\"; System.out.println(\"Producer：\"+ msg); this.rabbitTemplate.convertAndSend(AmqpConfiguration.WORK_MODEL_QUEUE, msg); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }} 消费者 12345678910111213141516171819202122232425262728/** * 消费者1 * @param msg */ @RabbitListener(queues = AmqpConfiguration.WORK_MODEL_QUEUE) public void consumer1(String msg){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"consumer1 : \" + msg); } /** * 消费者2 * @param msg */ @RabbitListener(queues = AmqpConfiguration.WORK_MODEL_QUEUE) public void consumer2(String msg){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"consumer2 : \" + msg); } 3) 订阅模型-Fanout 订阅模型-Fanout也成为广播模式，流程如下 可以有多个消费者 每个消费者有自己的队列 每个队列都要绑定到Exchange（交换机） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 交换机把消息发送给绑定过的所有队列 队列的消费者都能拿到消息。实现一条消息被多个消费者消费","link":"/2020/01/13/SpringBoot-RabbitMQ%E7%A4%BA%E4%BE%8B%E6%95%B4%E5%90%88/"},{"title":"lhy","text":"我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉； 也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。 不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。 我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。","link":"/2020/01/10/lhy/"},{"title":"测试-标题图片发布","text":"测试发布新的博文(图文发布)","link":"/2020/01/09/test/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"lhy","slug":"lhy","link":"/tags/lhy/"}],"categories":[{"name":"Java技术分享","slug":"Java技术分享","link":"/categories/Java%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"人物","slug":"人物","link":"/categories/%E4%BA%BA%E7%89%A9/"}]}